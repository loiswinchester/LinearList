#include<stdio.h>
#include<stdbool.h>
#include <malloc.h>
//不带头节点的单链表
typedef struct LNode {//typedef：数据类型重命名；typedef<数据类型><别名>
	int data;
	struct LNode *next;//指针指向下一个节点
} LNode, * LinkList;

//初始化一个空的单链表（不带头节点）
//bool InitList(LinkList L) {//&L
//	L = NULL;//空表，此表中还没有任何节点
//	return true;
//}
bool InitList(LinkList L) {
	L = (LNode*)malloc(sizeof(LNode));//分配一个头节点
	if (L == NULL)//内存不足，分配失败
		return false;
	L->data = NULL;//头节点之后暂时还没有节点
	return true;
}
void test() {
	LinkList L;//声明一个指向单链表的指针
	InitList(L);
}
//判断是否为空
bool Empty(LinkList L) {
	if (L == NULL)//带头节点判空：L->next==NULL
		return true;
	else
		return false;
}
//在第i个位置插入元素e（带头节点）
bool ListInsert(LinkList L, int i, int e) {
	if (i < 1)
		return false;
	//if (i == 1) {//不带头节点的单链表按位序插入，插入第一个节点的操作与其他节点不同
	//	LNode* s = (LNode*)malloc(sizeof(LNode));
	//	s->data = e;
	//	s->next = L;
	//	L = s;//头指针指向新节点
	//	return true;
	//}
	LNode* p;//指针p指向当前扫描到的节点
	int j = 0;//当前p指向第几个节点
	p = L;//L指向头节点，头节点是第0个节点，不存数据
	while (p != NULL && j < i - 1) {//循环找到第i-1个节点
		p = p->next;
		j++;
	}//以上代码是为了找到第i-1个节点
	if (p == NULL)//i值不合法
		return false;
	LNode* s = (LNode*)malloc(sizeof(LNode));
	s->data = e;
	s->next = p->next;
	p->next = s;//将节点s连接到p之后
	return true;
}
